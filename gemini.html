<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Strike: Neon Arena</title>
    <style>
        :root {
            --p1-color: #00f7ff;
            --p2-color: #ff0040;
            --bg-grad-start: #050505;
            --bg-grad-end: #1a1a2e;
            --ui-font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: radial-gradient(circle at center, var(--bg-grad-end), var(--bg-grad-start));
            color: white;
            font-family: var(--ui-font);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 1280px;
            max-height: 720px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        /* HUD */
        .hud {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
        }

        .health-container {
            width: 40%;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .bar-frame {
            height: 25px;
            background: #333;
            border: 2px solid #555;
            transform: skewX(-20deg);
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .health-fill {
            height: 100%;
            width: 100%;
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .p1-bar .health-fill {
            background: linear-gradient(90deg, #0055ff, var(--p1-color));
        }

        .p2-bar .health-fill {
            background: linear-gradient(90deg, var(--p2-color), #880022);
            float: right;
        }

        .name-tag {
            font-size: 1.2rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px currentColor;
        }

        .p1-name {
            color: var(--p1-color);
            text-align: left;
        }

        .p2-name {
            color: var(--p2-color);
            text-align: right;
        }

        .timer-box {
            width: 80px;
            height: 60px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #555;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
            color: #fff;
            transform: skewX(-10deg);
        }

        /* Notifications (Round 1, Fight, KO) */
        #notification-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 5rem;
            font-weight: 900;
            text-transform: uppercase;
            font-style: italic;
            opacity: 0;
            transition: opacity 0.3s;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            z-index: 10;
        }

        .notification-anim {
            animation: pulseZoom 1.5s forwards;
        }

        @keyframes pulseZoom {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }

            20% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }

            80% {
                transform: translate(-50%, -50%) scale(1.0);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0;
            }
        }

        /* Menu Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 20;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 5rem;
            margin-bottom: 20px;
            background: linear-gradient(to right, var(--p1-color), white, var(--p2-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: transparent;
            border: 2px solid white;
            color: white;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.2s;
            margin-top: 20px;
        }

        .btn:hover {
            background: white;
            color: black;
            box-shadow: 0 0 20px white;
        }

        .controls-info {
            margin-top: 40px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            text-align: left;
            font-size: 0.9rem;
            color: #aaa;
            border-top: 1px solid #333;
            padding-top: 20px;
        }

        .key {
            display: inline-block;
            background: #333;
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            margin-right: 5px;
            border-bottom: 2px solid #111;
        }

        /* Combo Counter */
        #combo-display {
            position: absolute;
            left: 20px;
            top: 150px;
            font-size: 2rem;
            color: #ffd700;
            font-style: italic;
            font-weight: bold;
            opacity: 0;
            transform: translateX(-50px);
            transition: transform 0.2s, opacity 0.2s;
        }

        .combo-active {
            opacity: 1 !important;
            transform: translateX(0) !important;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <!-- UI Layer -->
        <div class="ui-layer">
            <div class="hud">
                <div class="health-container p1-bar">
                    <div class="name-tag p1-name">Player</div>
                    <div class="bar-frame">
                        <div class="health-fill" id="p1-health"></div>
                    </div>
                </div>

                <div class="timer-box" id="timer">60</div>

                <div class="health-container p2-bar">
                    <div class="name-tag p2-name">Shadow AI</div>
                    <div class="bar-frame">
                        <div class="health-fill" id="p2-health"></div>
                    </div>
                </div>
            </div>

            <div id="combo-display">0 HITS</div>

            <!-- Controls Guide (Bottom) -->
            <div style="text-align: center; color: #555; font-size: 0.8rem; margin-bottom: 10px;">
                WASD to Move/Jump &nbsp;|&nbsp; J=Punch &nbsp;|&nbsp; K=Kick &nbsp;|&nbsp; L=Special &nbsp;|&nbsp;
                I=Block
            </div>
        </div>

        <!-- Notification Overlay -->
        <div id="notification-overlay">ROUND 1</div>

        <!-- Menu Screen -->
        <div id="menu-screen" class="screen">
            <h1>SHADOW STRIKE</h1>
            <p style="color: #888; letter-spacing: 2px; margin-bottom: 20px;">NEON ARENA</p>
            <button class="btn" onclick="startGame()">ENTER ARENA</button>

            <div class="controls-info">
                <div>
                    <h3>PLAYER 1</h3>
                    <p><span class="key">A</span><span class="key">D</span> Move</p>
                    <p><span class="key">W</span> Jump</p>
                    <p><span class="key">I</span> Block</p>
                </div>
                <div>
                    <h3>ATTACKS</h3>
                    <p><span class="key">J</span> Punch (Fast)</p>
                    <p><span class="key">K</span> Kick (Medium)</p>
                    <p><span class="key">L</span> Special (Heavy)</p>
                </div>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen hidden">
            <h1 id="result-title">YOU WIN</h1>
            <button class="btn" onclick="resetGame()">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        /**
         * SHADOW STRIKE: NEON ARENA
         * Complete Game Engine in Single File
         */

        // --- CONFIGURATION ---
        const CONSTANTS = {
            GRAVITY: 0.8,
            FRICTION: 0.85,
            GROUND_Y: 0, // Set dynamically on resize
            FPS: 60,
            P1_COLOR: '#00f7ff',
            P2_COLOR: '#ff0040',
            HIT_STUN: 20, // Frames
            BLOCK_REDUCTION: 0.3 // 70% reduction
        };

        // --- AUDIO ENGINE (Web Audio API) ---
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.enabled = false;
            }

            init() {
                if (this.ctx) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3; // Prevent ear bleeding
                this.masterGain.connect(this.ctx.destination);
                this.enabled = true;
            }

            playTone(freq, type, duration, vol = 1, slideTo = null) {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if (slideTo) {
                    osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
                }

                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playNoise(duration, vol = 1) {
                if (!this.enabled) return;
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();

                // Bandpass filter for "thud" vs "hiss"
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;

                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start();
            }

            playPunch() { this.playNoise(0.1, 0.8); this.playTone(150, 'triangle', 0.1, 0.5, 50); }
            playKick() { this.playNoise(0.2, 0.9); this.playTone(100, 'square', 0.15, 0.6, 40); }
            playHit() { this.playNoise(0.3, 1.0); this.playTone(80, 'sawtooth', 0.2, 0.8, 10); }
            playBlock() { this.playTone(800, 'square', 0.05, 0.5); } // Metallic clink
            playSpecial() { this.playTone(400, 'sawtooth', 0.5, 0.8, 50); this.playNoise(0.5, 0.5); }
            playKO() { this.playTone(200, 'sawtooth', 2.0, 1.0, 10); }
        }
        const audio = new SoundManager();

        // --- INPUT HANDLER ---
        class InputHandler {
            constructor() {
                this.keys = {};
                window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
                window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
            }
            isDown(key) { return this.keys[key.toLowerCase()]; }
        }
        const input = new InputHandler();

        // --- PARTICLE SYSTEM ---
        class Particle {
            constructor(x, y, color, speed, size, type) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
                this.type = type; // 'spark', 'blood', 'dust'
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;

                if (this.type === 'blood' || this.type === 'dust') {
                    this.vy += 0.2; // Gravity
                }
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;

                if (this.type === 'spark') {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                }

                ctx.fillRect(this.x, this.y, this.size, this.size);

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;
            }
        }

        // --- FIGHTER CLASS ---
        class Fighter {
            constructor(x, y, color, isAi = false, facingRight = true) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.width = 40;
                this.height = 100;
                this.color = color;
                this.isAi = isAi;
                this.facingRight = facingRight;

                // Stats
                this.health = 100;
                this.maxHealth = 100;

                // State
                this.state = 'idle'; // idle, run, jump, punch, kick, special, block, hit, dead
                this.frame = 0;
                this.isGrounded = false;

                // Combat
                this.attackCooldown = 0;
                this.stunTimer = 0;
                this.hitbox = { x: 0, y: 0, w: 0, h: 0, active: false };

                // Stick figure animation nodes
                this.nodes = {
                    head: { x: 0, y: -80 },
                    shoulder: { x: 0, y: -60 },
                    elbowL: { x: -20, y: -40 }, handL: { x: -20, y: -20 },
                    elbowR: { x: 20, y: -40 }, handR: { x: 20, y: -20 },
                    hip: { x: 0, y: 0 },
                    kneeL: { x: -15, y: 30 }, footL: { x: -20, y: 60 },
                    kneeR: { x: 15, y: 30 }, footR: { x: 20, y: 60 }
                };
            }

            update(enemy, particles, bounds) {
                // State Management
                if (this.health <= 0 && this.state !== 'dead') {
                    this.state = 'dead';
                    this.frame = 0;
                }

                if (this.state === 'dead') {
                    this.y = Math.min(this.y + 5, bounds.height - 20); // Fall to ground
                    return;
                }

                if (this.stunTimer > 0) {
                    this.stunTimer--;
                    this.state = 'hit';
                    if (this.stunTimer <= 0) this.state = 'idle';
                } else if (this.attackCooldown > 0) {
                    this.attackCooldown--;
                    // Stay in attack state until animation finishes (simulated by cooldown/frames)
                    if (this.attackCooldown < 10 && this.state !== 'jump') this.state = 'idle';
                }

                // AI Logic
                if (this.isAi && this.state !== 'hit' && this.state !== 'dead') {
                    this.runAI(enemy);
                }
                // Player Input
                else if (!this.isAi && this.state !== 'hit' && this.state !== 'dead' && this.attackCooldown <= 0) {
                    this.handleInput();
                }

                // Physics
                this.vy += CONSTANTS.GRAVITY;
                this.x += this.vx;
                this.y += this.vy;

                this.vx *= CONSTANTS.FRICTION;

                // Ground Collision
                if (this.y >= bounds.height - 20) {
                    this.y = bounds.height - 20;
                    this.vy = 0;
                    this.isGrounded = true;
                    if (this.state === 'jump') this.state = 'idle';
                } else {
                    this.isGrounded = false;
                }

                // Wall Collision
                if (this.x < 20) this.x = 20;
                if (this.x > bounds.width - 20) this.x = bounds.width - 20;

                // Face Enemy
                if (this.state !== 'dead' && this.attackCooldown <= 0) {
                    this.facingRight = this.x < enemy.x;
                }

                // Push Collision (Don't walk through each other)
                const dx = this.x - enemy.x;
                const dy = this.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 40 && Math.abs(dy) < 80) {
                    const push = (40 - dist) / 2;
                    if (this.x < enemy.x) this.x -= push; else this.x += push;
                }

                this.checkAttackHit(enemy, particles);
                this.animate();
            }

            handleInput() {
                if (input.isDown('a')) this.vx -= 1.5;
                if (input.isDown('d')) this.vx += 1.5;
                if (input.isDown('w') && this.isGrounded) { this.vy = -18; this.state = 'jump'; }

                if (Math.abs(this.vx) > 0.5 && this.isGrounded) this.state = 'run';
                else if (this.isGrounded) this.state = 'idle';

                if (input.isDown('i')) { this.state = 'block'; this.vx *= 0.5; }

                // Attacks
                if (input.isDown('j')) this.performAttack('punch', 20, 5);
                else if (input.isDown('k')) this.performAttack('kick', 30, 10);
                else if (input.isDown('l')) this.performAttack('special', 60, 20);
            }

            runAI(enemy) {
                const dist = Math.abs(this.x - enemy.x);

                // Reaction delay simulated by only acting every few frames or random chance
                if (Math.random() < 0.1) {
                    if (dist > 150) {
                        // Move closer
                        this.vx += (this.x < enemy.x) ? 1.0 : -1.0;
                        this.state = 'run';
                    } else if (dist < 100) {
                        // Combat Range
                        const roll = Math.random();
                        if (enemy.attackCooldown > 10 && roll < 0.4) {
                            this.state = 'block'; // Defensive
                        } else {
                            if (roll < 0.3) this.performAttack('punch', 20, 5);
                            else if (roll < 0.6) this.performAttack('kick', 30, 10);
                            else if (roll < 0.7) this.performAttack('special', 60, 20);
                        }
                    }
                }
            }

            performAttack(type, cooldown, damage) {
                this.state = type;
                this.attackCooldown = cooldown;
                this.frame = 0;
                this.hitbox.active = true;
                this.hitbox.damage = damage;
                this.hitbox.type = type;

                // Initial Lunge
                this.vx = this.facingRight ? 5 : -5;

                // Sounds
                if (type === 'punch') audio.playPunch();
                if (type === 'kick') audio.playKick();
                if (type === 'special') audio.playSpecial();
            }

            checkAttackHit(enemy, particles) {
                if (!this.hitbox.active || this.state === 'hit' || this.state === 'dead') return;

                // Only active during middle of animation
                const progress = 1 - (this.attackCooldown / (this.hitbox.type === 'special' ? 60 : 30));
                if (progress < 0.3 || progress > 0.7) return;

                // Define attack box relative to player
                const range = this.hitbox.type === 'kick' ? 90 : (this.hitbox.type === 'special' ? 120 : 60);
                const hitX = this.facingRight ? this.x + range / 2 : this.x - range / 2;

                // Simple 1D distance check for X, height check for Y
                const dx = Math.abs(hitX - enemy.x);
                const dy = Math.abs(this.y - enemy.y);

                if (dx < range && dy < 80) {
                    enemy.takeHit(this.hitbox.damage, this.x, this.hitbox.type, particles);
                    this.hitbox.active = false; // Only hit once per attack

                    // Effect
                    game.freezeFrame(3); // Hit stop
                    game.combo++;
                    game.comboTimer = 60;
                }
            }

            takeHit(damage, sourceX, type, particles) {
                if (this.state === 'dead') return;

                let finalDamage = damage;
                let isBlocked = false;

                if (this.state === 'block' && ((sourceX < this.x && !this.facingRight) || (sourceX > this.x && this.facingRight))) {
                    finalDamage *= CONSTANTS.BLOCK_REDUCTION;
                    isBlocked = true;
                    audio.playBlock();
                    this.vx = (this.x > sourceX) ? 5 : -5; // Pushback on block
                } else {
                    this.health -= damage;
                    this.state = 'hit';
                    this.stunTimer = CONSTANTS.HIT_STUN;
                    this.attackCooldown = 0; // Cancel current attack

                    // Knockback
                    const force = type === 'special' ? 15 : 5;
                    this.vx = (this.x > sourceX) ? force : -force;
                    this.vy = -3;

                    audio.playHit();
                    game.shakeScreen(5);

                    // Particles
                    for (let i = 0; i < 10; i++) particles.push(new Particle(this.x, this.y - 40, this.color, 5, 3, 'blood'));
                }

                // Damage Number (Visual only, implemented in Game Draw)
                game.addDamageText(finalDamage, this.x, this.y - 80, isBlocked);

                if (this.health <= 0) {
                    this.health = 0;
                    audio.playKO();
                    game.slowMotion();
                }
            }

            animate() {
                this.frame++;
                const t = this.frame * 0.2;
                const dir = this.facingRight ? 1 : -1;

                // Reset offsets
                let n = this.nodes;

                // Procedural Animation Logic based on State
                switch (this.state) {
                    case 'idle':
                        n.head.y = -80 + Math.sin(t) * 2;
                        n.shoulder.y = -60 + Math.sin(t) * 2;
                        n.handL.x = -20 * dir; n.handL.y = -20 + Math.sin(t + 1) * 5;
                        n.handR.x = 20 * dir; n.handR.y = -20 + Math.sin(t + 2) * 5;
                        break;
                    case 'run':
                        n.kneeL.x = -15 + Math.sin(t * 2) * 20; n.footL.x = n.kneeL.x + Math.sin(t * 2) * 10;
                        n.kneeR.x = 15 + Math.cos(t * 2) * 20; n.footR.x = n.kneeR.x + Math.cos(t * 2) * 10;
                        n.handL.x = -20 * dir + Math.cos(t * 2) * 30;
                        n.handR.x = 20 * dir + Math.sin(t * 2) * 30;
                        break;
                    case 'punch':
                        n.handR.x = 60 * dir; n.handR.y = -60;
                        n.shoulder.x = 10 * dir;
                        break;
                    case 'kick':
                        n.footR.x = 60 * dir; n.footR.y = -40;
                        n.kneeR.x = 30 * dir; n.kneeR.y = -20;
                        break;
                    case 'special':
                        n.handR.x = 40 * dir; n.handR.y = -100; // Hand up
                        n.handL.x = -40 * dir; n.handL.y = 0;
                        n.footR.x = 40 * dir; n.footR.y = -20;
                        break;
                    case 'block':
                        n.handL.x = 10 * dir; n.handL.y = -50;
                        n.handR.x = 15 * dir; n.handR.y = -55;
                        break;
                    case 'hit':
                        n.head.x = -10 * dir; n.head.y = -70;
                        n.shoulder.x = -10 * dir;
                        break;
                    case 'dead':
                        n.head.y = 0; n.head.x = -30 * dir;
                        n.shoulder.y = 10; n.shoulder.x = -10 * dir;
                        n.hip.y = 15;
                        n.footL.y = 20; n.footR.y = 20;
                        break;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Shadow Effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.strokeStyle = '#000'; // Inner black
                ctx.fillStyle = '#000';
                ctx.lineWidth = 12;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Helper to draw limb
                const limb = (start, end) => {
                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                };

                const n = this.nodes;

                // Legs
                limb(n.hip, n.kneeL); limb(n.kneeL, n.footL);
                limb(n.hip, n.kneeR); limb(n.kneeR, n.footR);

                // Torso
                limb(n.hip, n.shoulder);

                // Arms
                limb(n.shoulder, n.elbowL); limb(n.elbowL, n.handL);
                limb(n.shoulder, n.elbowR); limb(n.elbowR, n.handR);

                // Head
                ctx.beginPath();
                ctx.arc(n.head.x, n.head.y, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Glow overlay for style
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
                ctx.shadowBlur = 0;

                // Simple wireframe over top to emphasize color
                limb(n.hip, n.shoulder);
                ctx.beginPath(); ctx.arc(n.head.x, n.head.y, 12, 0, Math.PI * 2); ctx.stroke();

                ctx.restore();
            }
        }

        // --- MAIN GAME CLASS ---
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.particles = [];
                this.damageTexts = [];

                this.player = null;
                this.enemy = null;

                this.timer = 60;
                this.combo = 0;
                this.comboTimer = 0;

                this.shake = 0;
                this.timeScale = 1.0;
                this.freezeTimer = 0;

                this.gameState = 'MENU'; // MENU, PLAY, GAMEOVER
                this.lastTime = 0;

                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            resize() {
                this.canvas.width = document.getElementById('game-container').offsetWidth;
                this.canvas.height = document.getElementById('game-container').offsetHeight;
                CONSTANTS.GROUND_Y = this.canvas.height - 20;
            }

            start() {
                this.gameState = 'PLAY';
                audio.init();

                // Spawn Fighters
                const ground = this.canvas.height - 20;
                this.player = new Fighter(200, ground, CONSTANTS.P1_COLOR, false);
                this.enemy = new Fighter(this.canvas.width - 200, ground, CONSTANTS.P2_COLOR, true, false);

                this.timer = 60;
                this.particles = [];
                this.damageTexts = [];
                this.timeScale = 1.0;

                document.getElementById('menu-screen').classList.add('hidden');
                document.getElementById('game-over-screen').classList.add('hidden');

                this.showNotification('ROUND 1');
                setTimeout(() => this.showNotification('FIGHT!'), 1500);

                // Start Timer
                if (this.timerInterval) clearInterval(this.timerInterval);
                this.timerInterval = setInterval(() => {
                    if (this.gameState === 'PLAY' && this.timer > 0 && this.timeScale > 0.5) {
                        this.timer--;
                        document.getElementById('timer').innerText = this.timer;
                        if (this.timer === 0) this.endRound();
                    }
                }, 1000);
            }

            loop(timestamp) {
                const dt = (timestamp - this.lastTime) / 1000;
                this.lastTime = timestamp;

                if (this.gameState === 'PLAY') {
                    if (this.freezeTimer > 0) {
                        this.freezeTimer--;
                    } else {
                        this.update();
                    }
                }

                this.draw();
                requestAnimationFrame(this.loop);
            }

            update() {
                if (this.timeScale < 1.0) {
                    // Very primitive slow motion implementation by skipping updates
                    if (Math.random() > this.timeScale) return;
                }

                // Screen Shake decay
                if (this.shake > 0) this.shake *= 0.9;
                if (this.shake < 0.5) this.shake = 0;

                // Combo Logic
                if (this.comboTimer > 0) {
                    this.comboTimer--;
                    document.getElementById('combo-display').innerText = this.combo + " HITS";
                    document.getElementById('combo-display').classList.add('combo-active');
                } else {
                    this.combo = 0;
                    document.getElementById('combo-display').classList.remove('combo-active');
                }

                const bounds = { width: this.canvas.width, height: this.canvas.height };

                this.player.update(this.enemy, this.particles, bounds);
                this.enemy.update(this.player, this.particles, bounds);

                // Update Particles
                this.particles.forEach((p, i) => {
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                });

                // Update Floating Text
                this.damageTexts.forEach((t, i) => {
                    t.y -= 1;
                    t.life -= 0.02;
                    if (t.life <= 0) this.damageTexts.splice(i, 1);
                });

                // UI Updates
                document.getElementById('p1-health').style.width = this.player.health + '%';
                document.getElementById('p2-health').style.width = this.enemy.health + '%';

                // Check End Condition
                if (this.player.health <= 0 || this.enemy.health <= 0) {
                    this.endRound();
                }
            }

            draw() {
                // Clear & Background
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Parallax Background Stars/Dust
                this.ctx.save();
                if (this.shake > 0) {
                    this.ctx.translate((Math.random() - 0.5) * this.shake, (Math.random() - 0.5) * this.shake);
                }

                // Floor
                this.ctx.fillStyle = '#111';
                this.ctx.fillRect(0, this.canvas.height - 20, this.canvas.width, 20);

                // Draw moon (Static for performance in this simple loop)
                this.ctx.shadowBlur = 50;
                this.ctx.shadowColor = '#fff';
                this.ctx.fillStyle = '#eee';
                this.ctx.beginPath();
                this.ctx.arc(this.canvas.width / 2, 100, 40, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;

                // Fighters
                if (this.player) this.player.draw(this.ctx);
                if (this.enemy) this.enemy.draw(this.ctx);

                // Particles
                this.particles.forEach(p => p.draw(this.ctx));

                // Damage Text
                this.ctx.font = "bold 24px Arial";
                this.ctx.textAlign = "center";
                this.damageTexts.forEach(t => {
                    this.ctx.globalAlpha = t.life;
                    this.ctx.fillStyle = t.isBlocked ? '#aaa' : '#fff';
                    this.ctx.strokeStyle = '#000';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeText(t.text, t.x, t.y);
                    this.ctx.fillText(t.text, t.x, t.y);
                });
                this.ctx.globalAlpha = 1;

                this.ctx.restore();
            }

            addDamageText(amount, x, y, isBlocked) {
                this.damageTexts.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y,
                    text: isBlocked ? "BLOCK" : Math.floor(amount),
                    life: 1.0,
                    isBlocked: isBlocked
                });
            }

            freezeFrame(frames) {
                this.freezeTimer = frames;
            }

            shakeScreen(intensity) {
                this.shake = intensity;
            }

            slowMotion() {
                this.timeScale = 0.2;
            }

            showNotification(text) {
                const el = document.getElementById('notification-overlay');
                el.innerText = text;
                el.classList.remove('notification-anim');
                void el.offsetWidth; // Trigger reflow
                el.classList.add('notification-anim');
            }

            endRound() {
                if (this.gameState !== 'PLAY') return;

                // Ensure one frame of dead state is processed
                if (this.player.health <= 0) this.player.state = 'dead';
                if (this.enemy.health <= 0) this.enemy.state = 'dead';

                this.gameState = 'GAMEOVER';
                this.showNotification('K.O.!');

                setTimeout(() => {
                    const screen = document.getElementById('game-over-screen');
                    const title = document.getElementById('result-title');

                    if (this.player.health > this.enemy.health) {
                        title.innerText = "YOU WIN";
                        title.style.color = CONSTANTS.P1_COLOR;
                    } else {
                        title.innerText = "DEFEAT";
                        title.style.color = CONSTANTS.P2_COLOR;
                    }
                    screen.classList.remove('hidden');
                }, 2000);
            }
        }

        // --- GLOBAL INIT ---
        const game = new Game();

        window.startGame = function () {
            game.start();
        };

        window.resetGame = function () {
            game.start();
        };

    </script>
</body>

</html>