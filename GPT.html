<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
    <title>Shadow Fight — Single File</title>
    <style>
        :root {
            --bg1: #0a0a0a;
            --bg2: #1a1a2e;
            --cyan: #00f7ff;
            --red: #ff0040;
            --ui: #cfd6ff;
            --glass: rgba(20, 24, 44, .45);
            --metal1: rgba(255, 255, 255, .12);
            --metal2: rgba(0, 0, 0, .55);
            --shadow: rgba(0, 0, 0, .6);
            --good: #39ff88;
            --warn: #ffd34d;
            --bad: #ff3b3b;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: radial-gradient(1200px 700px at 70% 10%, rgba(64, 90, 255, .14), transparent 60%),
                linear-gradient(180deg, var(--bg1), var(--bg2));
            color: var(--ui);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
            overflow: hidden;
        }

        /* Atmospheric parallax layers */
        #parallax {
            position: fixed;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
        }

        #moon {
            position: absolute;
            width: min(340px, 40vw);
            aspect-ratio: 1/1;
            right: 6vw;
            top: 6vh;
            border-radius: 50%;
            background:
                radial-gradient(circle at 30% 30%, rgba(255, 255, 255, .95), rgba(255, 255, 255, .25) 55%, rgba(180, 200, 255, .06) 70%, transparent 76%),
                radial-gradient(circle at 55% 65%, rgba(255, 255, 255, .08), transparent 55%);
            filter: drop-shadow(0 0 25px rgba(120, 170, 255, .35)) drop-shadow(0 0 60px rgba(120, 170, 255, .15));
            animation: moonFloat 10s ease-in-out infinite;
            opacity: .9;
        }

        @keyframes moonFloat {

            0%,
            100% {
                transform: translateY(0px) translateX(0px)
            }

            50% {
                transform: translateY(-10px) translateX(-6px)
            }
        }

        /* Mist bands */
        .mist {
            position: absolute;
            left: -20%;
            right: -20%;
            height: 24vh;
            background: radial-gradient(closest-side at 30% 40%, rgba(120, 180, 255, .12), transparent 70%),
                radial-gradient(closest-side at 70% 55%, rgba(255, 90, 140, .08), transparent 75%),
                linear-gradient(90deg, transparent, rgba(255, 255, 255, .04), transparent);
            filter: blur(10px);
            opacity: .45;
            animation: mistMove 18s linear infinite;
        }

        .mist.m1 {
            top: 14vh;
            animation-duration: 22s;
        }

        .mist.m2 {
            top: 38vh;
            opacity: .32;
            animation-duration: 28s;
        }

        .mist.m3 {
            top: 58vh;
            opacity: .22;
            animation-duration: 34s;
        }

        @keyframes mistMove {
            0% {
                transform: translateX(0)
            }

            100% {
                transform: translateX(10%)
            }
        }

        /* Floating dust (CSS particles) */
        #dust {
            position: absolute;
            inset: 0;
            opacity: .45;
            filter: blur(.2px);
            background:
                radial-gradient(circle at 10% 20%, rgba(255, 255, 255, .08) 0 1px, transparent 2px),
                radial-gradient(circle at 30% 70%, rgba(255, 255, 255, .06) 0 1px, transparent 2px),
                radial-gradient(circle at 60% 35%, rgba(255, 255, 255, .05) 0 1px, transparent 2px),
                radial-gradient(circle at 80% 60%, rgba(255, 255, 255, .07) 0 1px, transparent 2px),
                radial-gradient(circle at 50% 85%, rgba(255, 255, 255, .05) 0 1px, transparent 2px);
            background-size: 400px 400px;
            animation: dustDrift 14s linear infinite;
        }

        @keyframes dustDrift {
            0% {
                transform: translateY(0)
            }

            100% {
                transform: translateY(40px)
            }
        }

        /* Game layout */
        #app {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            padding: 16px;
        }

        #gameWrap {
            position: relative;
            width: min(1280px, 96vw);
            aspect-ratio: 16/9;
            border-radius: 22px;
            overflow: hidden;
            box-shadow: 0 30px 90px rgba(0, 0, 0, .55), 0 0 0 1px rgba(255, 255, 255, .06) inset;
            background: linear-gradient(180deg, rgba(0, 0, 0, .35), rgba(0, 0, 0, .55));
            backdrop-filter: blur(10px);
        }

        #gameWrap::before {
            content: "";
            position: absolute;
            inset: 0;
            background:
                radial-gradient(1200px 600px at 50% 20%, rgba(0, 247, 255, .06), transparent 60%),
                radial-gradient(900px 500px at 55% 60%, rgba(255, 0, 64, .05), transparent 62%),
                linear-gradient(180deg, rgba(0, 0, 0, .08), rgba(0, 0, 0, .2));
            pointer-events: none;
            mix-blend-mode: screen;
            opacity: .9;
        }

        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        /* HUD */
        #hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        #topHUD {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 14px;
            padding: 14px 16px;
            align-items: start;
        }

        .hpPanel {
            background: linear-gradient(180deg, rgba(255, 255, 255, .07), rgba(0, 0, 0, .35));
            border: 1px solid rgba(255, 255, 255, .10);
            border-radius: 16px;
            padding: 10px 12px 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .35), 0 0 0 1px rgba(0, 0, 0, .25) inset;
            backdrop-filter: blur(10px);
            overflow: hidden;
            position: relative;
        }

        .hpPanel::after {
            content: "";
            position: absolute;
            inset: -2px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, .10), transparent);
            transform: translateX(-40%);
            animation: sheen 4.2s ease-in-out infinite;
            pointer-events: none;
            opacity: .65;
        }

        @keyframes sheen {

            0%,
            100% {
                transform: translateX(-55%);
                opacity: .2
            }

            50% {
                transform: translateX(55%);
                opacity: .55
            }
        }

        .hpHeader {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 700;
            letter-spacing: .06em;
            font-size: 12px;
            text-transform: uppercase;
            color: rgba(220, 230, 255, .92);
            text-shadow: 0 0 14px rgba(120, 170, 255, .15);
            margin-bottom: 8px;
        }

        .tag {
            font-weight: 800;
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(0, 0, 0, .28);
            box-shadow: 0 6px 18px rgba(0, 0, 0, .25);
        }

        .tag.cyan {
            color: rgba(0, 247, 255, .95);
            text-shadow: 0 0 16px rgba(0, 247, 255, .25);
        }

        .tag.red {
            color: rgba(255, 0, 64, .95);
            text-shadow: 0 0 16px rgba(255, 0, 64, .25);
        }

        .bar {
            height: 16px;
            border-radius: 999px;
            overflow: hidden;
            background: rgba(0, 0, 0, .35);
            border: 1px solid rgba(255, 255, 255, .10);
            box-shadow: 0 8px 18px rgba(0, 0, 0, .32), 0 0 0 1px rgba(0, 0, 0, .28) inset;
            position: relative;
        }

        .barFill {
            height: 100%;
            width: 100%;
            transform-origin: left center;
            transform: scaleX(1);
            background: linear-gradient(90deg,
                    var(--good) 0%,
                    var(--warn) 55%,
                    var(--bad) 100%);
            filter: saturate(1.2);
            box-shadow: 0 0 18px rgba(57, 255, 136, .15);
        }

        .barGloss {
            position: absolute;
            inset: 0;
            background: linear-gradient(180deg, rgba(255, 255, 255, .22), transparent 55%);
            opacity: .35;
            pointer-events: none;
        }

        .p2 .barFill {
            transform-origin: right center;
        }

        .p2 .barFill {
            background: linear-gradient(90deg,
                    var(--bad) 0%,
                    var(--warn) 45%,
                    var(--good) 100%);
        }

        #centerHUD {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding-top: 6px;
            min-width: 160px;
        }

        #timer {
            font-variant-numeric: tabular-nums;
            font-weight: 900;
            font-size: 28px;
            letter-spacing: .08em;
            padding: 8px 14px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: linear-gradient(180deg, rgba(255, 255, 255, .08), rgba(0, 0, 0, .38));
            box-shadow: 0 12px 40px rgba(0, 0, 0, .35);
            text-shadow: 0 0 18px rgba(160, 190, 255, .25);
            backdrop-filter: blur(10px);
        }

        #roundDots {
            display: flex;
            gap: 6px;
            align-items: center;
            justify-content: center;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .18);
            background: rgba(0, 0, 0, .35);
            box-shadow: 0 0 10px rgba(120, 170, 255, .12);
        }

        .dot.winP1 {
            background: rgba(0, 247, 255, .65);
            box-shadow: 0 0 14px rgba(0, 247, 255, .45);
        }

        .dot.winP2 {
            background: rgba(255, 0, 64, .65);
            box-shadow: 0 0 14px rgba(255, 0, 64, .45);
        }

        /* Combo */
        #combo {
            position: absolute;
            right: 18px;
            top: 98px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 6px;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-8px);
            transition: opacity .2s ease, transform .2s ease;
        }

        #combo.show {
            opacity: 1;
            transform: translateY(0);
        }

        #combo .count {
            font-weight: 900;
            font-size: 34px;
            letter-spacing: .04em;
            color: rgba(0, 247, 255, .95);
            text-shadow: 0 0 22px rgba(0, 247, 255, .35), 0 0 65px rgba(0, 247, 255, .12);
        }

        #combo .label {
            font-weight: 800;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: .14em;
            opacity: .85;
        }

        /* Announcements */
        #banner {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            pointer-events: none;
        }

        .bannerText {
            font-weight: 1000;
            font-size: clamp(44px, 6vw, 76px);
            letter-spacing: .14em;
            text-transform: uppercase;
            color: rgba(235, 245, 255, .95);
            text-shadow:
                0 0 24px rgba(0, 247, 255, .16),
                0 0 70px rgba(0, 247, 255, .08),
                0 14px 80px rgba(0, 0, 0, .55);
            opacity: 0;
            transform: translateY(8px) scale(.98);
            filter: blur(.1px);
            animation: pop .95s ease forwards;
        }

        .bannerText.redGlow {
            text-shadow:
                0 0 24px rgba(255, 0, 64, .18),
                0 0 70px rgba(255, 0, 64, .08),
                0 14px 80px rgba(0, 0, 0, .55);
        }

        @keyframes pop {
            0% {
                opacity: 0;
                transform: translateY(12px) scale(.98)
            }

            18% {
                opacity: 1;
                transform: translateY(0px) scale(1.02)
            }

            100% {
                opacity: 0;
                transform: translateY(-10px) scale(1.0)
            }
        }

        /* Menu / Game Over overlays */
        .overlay {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            padding: 18px;
            background: radial-gradient(1200px 700px at 50% 20%, rgba(0, 247, 255, .06), transparent 60%),
                radial-gradient(1000px 600px at 60% 55%, rgba(255, 0, 64, .05), transparent 62%),
                rgba(0, 0, 0, .45);
            backdrop-filter: blur(12px);
        }

        .panel {
            width: min(720px, 94vw);
            border-radius: 22px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: linear-gradient(180deg, rgba(255, 255, 255, .08), rgba(0, 0, 0, .52));
            box-shadow: 0 20px 70px rgba(0, 0, 0, .55), 0 0 0 1px rgba(0, 0, 0, .35) inset;
            padding: 28px 26px 24px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .panel::before {
            content: "";
            position: absolute;
            inset: -2px;
            background: radial-gradient(closest-side at 20% 20%, rgba(0, 247, 255, .18), transparent 55%),
                radial-gradient(closest-side at 80% 45%, rgba(255, 0, 64, .14), transparent 55%),
                linear-gradient(90deg, transparent, rgba(255, 255, 255, .10), transparent);
            opacity: .35;
            pointer-events: none;
            filter: blur(4px);
        }

        h1 {
            margin: 0 0 6px;
            font-size: clamp(44px, 6.5vw, 82px);
            letter-spacing: .18em;
            text-transform: uppercase;
            font-weight: 1000;
            color: rgba(235, 245, 255, .95);
            text-shadow:
                0 0 24px rgba(0, 247, 255, .22),
                0 0 60px rgba(0, 247, 255, .10),
                0 18px 90px rgba(0, 0, 0, .60);
        }

        .subtitle {
            margin: 6px 0 18px;
            font-weight: 700;
            letter-spacing: .08em;
            opacity: .82;
            text-transform: uppercase;
            font-size: 13px;
        }

        .press {
            display: inline-block;
            margin-top: 10px;
            font-weight: 900;
            letter-spacing: .18em;
            text-transform: uppercase;
            padding: 12px 18px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .14);
            background: rgba(0, 0, 0, .35);
            box-shadow: 0 10px 30px rgba(0, 0, 0, .45);
            animation: pulse 1.4s ease-in-out infinite;
            text-shadow: 0 0 18px rgba(0, 247, 255, .12);
            color: rgba(220, 230, 255, .92);
        }

        @keyframes pulse {

            0%,
            100% {
                transform: translateY(0);
                filter: brightness(1)
            }

            50% {
                transform: translateY(-2px);
                filter: brightness(1.12)
            }
        }

        .btnRow {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        button {
            pointer-events: auto;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, .16);
            border-radius: 14px;
            padding: 12px 16px;
            background: linear-gradient(180deg, rgba(255, 255, 255, .10), rgba(0, 0, 0, .45));
            color: rgba(240, 245, 255, .92);
            font-weight: 900;
            letter-spacing: .12em;
            text-transform: uppercase;
            box-shadow: 0 12px 40px rgba(0, 0, 0, .45);
            transition: transform .12s ease, filter .12s ease;
            backdrop-filter: blur(10px);
        }

        button:hover {
            transform: translateY(-1px);
            filter: brightness(1.12);
        }

        button:active {
            transform: translateY(1px);
            filter: brightness(.95);
        }

        /* Bottom controls guide */
        #controls {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 12px 14px;
            display: flex;
            justify-content: center;
            pointer-events: none;
        }

        #controls .card {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            padding: 10px 12px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, .10);
            background: rgba(0, 0, 0, .28);
            backdrop-filter: blur(10px);
            box-shadow: 0 14px 50px rgba(0, 0, 0, .45);
            font-size: 12px;
            letter-spacing: .06em;
            opacity: .92;
        }

        .key {
            padding: 3px 8px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, .14);
            background: linear-gradient(180deg, rgba(255, 255, 255, .10), rgba(0, 0, 0, .35));
            box-shadow: 0 8px 18px rgba(0, 0, 0, .35);
            font-weight: 900;
            color: rgba(235, 245, 255, .92);
        }

        .sep {
            opacity: .35;
        }

        /* Screen flash overlay */
        #flash {
            position: absolute;
            inset: 0;
            background: white;
            opacity: 0;
            pointer-events: none;
            mix-blend-mode: overlay;
        }

        /* Small helpers */
        .hide {
            display: none !important;
        }

        /* Reduced motion */
        @media (prefers-reduced-motion: reduce) {

            #moon,
            .mist,
            #dust,
            .press,
            .hpPanel::after {
                animation: none !important;
            }
        }
    </style>
</head>

<body>
    <div id="parallax">
        <div id="moon"></div>
        <div class="mist m1"></div>
        <div class="mist m2"></div>
        <div class="mist m3"></div>
        <div id="dust"></div>
    </div>

    <div id="app">
        <div id="gameWrap" aria-label="Shadow Fight Game">
            <canvas id="game" width="1280" height="720"></canvas>

            <div id="hud">
                <div id="topHUD">
                    <div class="hpPanel p1">
                        <div class="hpHeader">
                            <div>PLAYER</div>
                            <div class="tag cyan">P1</div>
                        </div>
                        <div class="bar" aria-label="Player Health">
                            <div class="barFill" id="p1Fill"></div>
                            <div class="barGloss"></div>
                        </div>
                    </div>

                    <div id="centerHUD">
                        <div id="timer">60</div>
                        <div id="roundDots" aria-label="Round Wins">
                            <div class="dot" id="r1"></div>
                            <div class="dot" id="r2"></div>
                            <div class="dot" id="r3"></div>
                        </div>
                    </div>

                    <div class="hpPanel p2">
                        <div class="hpHeader">
                            <div class="tag red">AI</div>
                            <div>ENEMY</div>
                        </div>
                        <div class="bar" aria-label="Enemy Health">
                            <div class="barFill" id="p2Fill"></div>
                            <div class="barGloss"></div>
                        </div>
                    </div>
                </div>

                <div id="combo">
                    <div class="count" id="comboCount">x2</div>
                    <div class="label">COMBO</div>
                </div>

                <div id="banner"></div>
            </div>

            <div id="flash"></div>

            <div id="controls">
                <div class="card">
                    <span class="key">A</span>/<span class="key">D</span> Move
                    <span class="sep">•</span>
                    <span class="key">W</span> Jump
                    <span class="sep">•</span>
                    <span class="key">J</span> Punch
                    <span class="sep">•</span>
                    <span class="key">K</span> Kick
                    <span class="sep">•</span>
                    <span class="key">L</span> Special (3s)
                    <span class="sep">•</span>
                    <span class="key">I</span> Block (hold)
                    <span class="sep">•</span>
                    <span class="key">ENTER</span> Start/Continue
                </div>
            </div>

            <div id="menu" class="overlay">
                <div class="panel">
                    <h1>SHADOW FIGHT</h1>
                    <div class="subtitle">2D SILHOUETTE DUEL • KEYBOARD VS SMART AI</div>
                    <div class="press">PRESS ENTER TO START</div>
                    <div class="subtitle" style="margin-top:18px; opacity:.72;">
                        Tip: Hold <span class="key">I</span> to reduce damage by 70%. Specials hit hard—watch the
                        cooldown.
                    </div>
                </div>
            </div>

            <div id="gameOver" class="overlay hide">
                <div class="panel">
                    <h1 id="gameOverTitle">YOU WIN</h1>
                    <div class="subtitle" id="gameOverSub">Best of 3 • Fight again?</div>
                    <div class="btnRow">
                        <button id="playAgain">PLAY AGAIN</button>
                        <button id="backMenu">MAIN MENU</button>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        (() => {
            "use strict";

            // -----------------------------
            // Utilities
            // -----------------------------
            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
            const lerp = (a, b, t) => a + (b - a) * t;
            const rand = (a, b) => a + Math.random() * (b - a);
            const randi = (a, b) => Math.floor(rand(a, b + 1));
            const now = () => performance.now();

            function rectsOverlap(a, b) {
                return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
            }

            // -----------------------------
            // Sound (Web Audio API)
            // -----------------------------
            class SoundManager {
                constructor() {
                    this.ctx = null;
                    this.master = null;
                    this.ambGain = null;
                    this.started = false;
                    this.lastHum = 0;
                }
                ensure() {
                    if (this.started) return;
                    const AC = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AC();
                    this.master = this.ctx.createGain();
                    this.master.gain.value = 0.55;
                    this.master.connect(this.ctx.destination);

                    this.ambGain = this.ctx.createGain();
                    this.ambGain.gain.value = 0.12;
                    this.ambGain.connect(this.master);

                    // Ambient hum (subtle, evolving)
                    const o1 = this.ctx.createOscillator();
                    const o2 = this.ctx.createOscillator();
                    const lfo = this.ctx.createOscillator();
                    const lfoGain = this.ctx.createGain();
                    o1.type = "sine"; o2.type = "triangle";
                    o1.frequency.value = 55;
                    o2.frequency.value = 110;
                    lfo.type = "sine";
                    lfo.frequency.value = 0.12;
                    lfoGain.gain.value = 8;

                    lfo.connect(lfoGain);
                    lfoGain.connect(o2.frequency);

                    const amb = this.ctx.createGain();
                    amb.gain.value = 0.18;

                    o1.connect(amb);
                    o2.connect(amb);
                    amb.connect(this.ambGain);

                    o1.start(); o2.start(); lfo.start();

                    this.started = true;
                }

                _noiseBurst(duration = 0.06, tone = 800, gain = 0.25, hp = 500) {
                    const c = this.ctx;
                    const bufferSize = Math.max(1, Math.floor(c.sampleRate * duration));
                    const buffer = c.createBuffer(1, bufferSize, c.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        // decaying noise
                        const t = i / bufferSize;
                        data[i] = (Math.random() * 2 - 1) * (1 - t) * (1 - t);
                    }

                    const src = c.createBufferSource();
                    src.buffer = buffer;

                    const biq = c.createBiquadFilter();
                    biq.type = "highpass";
                    biq.frequency.value = hp;

                    const lp = c.createBiquadFilter();
                    lp.type = "lowpass";
                    lp.frequency.value = tone;

                    const g = c.createGain();
                    g.gain.value = 0;
                    g.gain.setValueAtTime(0, c.currentTime);
                    g.gain.linearRampToValueAtTime(gain, c.currentTime + 0.005);
                    g.gain.exponentialRampToValueAtTime(0.001, c.currentTime + duration);

                    src.connect(biq);
                    biq.connect(lp);
                    lp.connect(g);
                    g.connect(this.master);

                    src.start();
                    src.stop(c.currentTime + duration + 0.02);
                }

                _toneSweep(duration = 0.18, f1 = 220, f2 = 880, gain = 0.25, type = "sawtooth") {
                    const c = this.ctx;
                    const o = c.createOscillator();
                    const g = c.createGain();
                    const biq = c.createBiquadFilter();
                    biq.type = "bandpass";
                    biq.frequency.value = 800;
                    biq.Q.value = 1.2;

                    o.type = type;
                    o.frequency.setValueAtTime(f1, c.currentTime);
                    o.frequency.exponentialRampToValueAtTime(f2, c.currentTime + duration);

                    g.gain.setValueAtTime(0.0001, c.currentTime);
                    g.gain.exponentialRampToValueAtTime(gain, c.currentTime + 0.02);
                    g.gain.exponentialRampToValueAtTime(0.0001, c.currentTime + duration);

                    o.connect(biq);
                    biq.connect(g);
                    g.connect(this.master);

                    o.start();
                    o.stop(c.currentTime + duration + 0.02);
                }

                punch() { this.ensure(); this._noiseBurst(0.06, 1400, 0.22, 700); }
                kick() { this.ensure(); this._noiseBurst(0.08, 900, 0.24, 450); }
                special() { this.ensure(); this._toneSweep(0.22, 180, 1200, 0.22, "sawtooth"); }
                hit() { this.ensure(); this._noiseBurst(0.08, 600, 0.26, 120); }
                block() {
                    this.ensure();
                    this._toneSweep(0.08, 700, 1200, 0.16, "square");
                    this._noiseBurst(0.05, 1400, 0.10, 900);
                }
                ko() {
                    this.ensure();
                    this._toneSweep(0.55, 260, 60, 0.28, "triangle");
                }
                roundStart() {
                    this.ensure();
                    this._toneSweep(0.20, 220, 880, 0.20, "sine");
                }
            }

            // -----------------------------
            // Particles / Floating text
            // -----------------------------
            class Particle {
                constructor(x, y, vx, vy, life, size, color, glow) {
                    this.x = x; this.y = y;
                    this.vx = vx; this.vy = vy;
                    this.life = life; this.maxLife = life;
                    this.size = size;
                    this.color = color;
                    this.glow = glow || color;
                    this.drag = 0.985;
                    this.gravity = 0;
                }
                update(dt) {
                    this.life -= dt;
                    this.vx *= Math.pow(this.drag, dt * 60);
                    this.vy *= Math.pow(this.drag, dt * 60);
                    this.vy += this.gravity * dt;
                    this.x += this.vx * dt;
                    this.y += this.vy * dt;
                }
                render(ctx) {
                    const t = clamp(this.life / this.maxLife, 0, 1);
                    const a = t * t;
                    ctx.save();
                    ctx.globalAlpha = a;
                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.glow;
                    ctx.shadowBlur = 18 * a;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * (0.6 + 0.6 * (1 - t)), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                get dead() { return this.life <= 0; }
            }

            class FloatingText {
                constructor(x, y, text, color, life = 0.8) {
                    this.x = x; this.y = y;
                    this.vy = -55;
                    this.life = life;
                    this.maxLife = life;
                    this.text = text;
                    this.color = color;
                }
                update(dt) {
                    this.life -= dt;
                    this.y += this.vy * dt;
                    this.vy *= Math.pow(0.96, dt * 60);
                }
                render(ctx) {
                    const t = clamp(this.life / this.maxLife, 0, 1);
                    ctx.save();
                    ctx.globalAlpha = t;
                    ctx.font = "900 22px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 16;
                    ctx.fillText(this.text, this.x, this.y);
                    ctx.restore();
                }
                get dead() { return this.life <= 0; }
            }

            // -----------------------------
            // Fighter
            // -----------------------------
            class Fighter {
                constructor(opts) {
                    this.id = opts.id;
                    this.name = opts.name;
                    this.isAI = !!opts.isAI;

                    this.glow = opts.glow;
                    this.core = "rgba(0,0,0,1)";

                    this.x = opts.x;
                    this.y = opts.y; // feet y
                    this.vx = 0;
                    this.vy = 0;
                    this.facing = opts.facing; // 1 right, -1 left

                    this.onGround = true;

                    this.maxHp = 100;
                    this.hp = 100;

                    this.state = "idle"; // idle/walk/jump/punch/kick/special/block/hit/ko/victory
                    this.stateT = 0;

                    this.attack = null; // {type, t, hitDone, wind, active, rec, dmgMin, dmgMax, stun, knock}
                    this.stunT = 0;

                    this.blocking = false;

                    this.specialCD = 0;

                    this.comboCount = 0;
                    this.lastComboHitAt = -999;

                    // Movement tuning
                    this.moveAccel = 2200;
                    this.maxSpeed = 520;
                    this.friction = 0.86;

                    this.jumpVel = 820;
                    this.gravity = 2200;

                    // Body dims for collision
                    this.bodyW = 70;
                    this.bodyH = 150;

                    this.ko = false;
                    this.victory = false;

                    // hit flash
                    this.flash = 0;
                }

                resetForRound(x, facing, floorY) {
                    this.x = x;
                    this.y = floorY;
                    this.vx = 0; this.vy = 0;
                    this.facing = facing;
                    this.onGround = true;

                    this.hp = this.maxHp;
                    this.state = "idle";
                    this.stateT = 0;
                    this.attack = null;
                    this.stunT = 0;
                    this.blocking = false;
                    this.specialCD = 0;
                    this.comboCount = 0;
                    this.lastComboHitAt = -999;
                    this.ko = false;
                    this.victory = false;
                    this.flash = 0;
                }

                get hurtbox() {
                    return {
                        x: this.x - this.bodyW / 2,
                        y: this.y - this.bodyH,
                        w: this.bodyW,
                        h: this.bodyH
                    };
                }

                canAct() {
                    return !this.ko && this.stunT <= 0 && !this.victory;
                }

                startAttack(type) {
                    if (!this.canAct()) return false;
                    if (this.attack) return false;
                    if (!this.onGround && type !== "punch" && type !== "kick") return false; // keep air attacks simple
                    if (this.blocking) return false;
                    if (type === "special" && this.specialCD > 0) return false;

                    let cfg;
                    if (type === "punch") {
                        cfg = { wind: 0.06, active: 0.10, rec: 0.14, dmgMin: 5, dmgMax: 8, stun: 0.30, knock: 220 };
                    } else if (type === "kick") {
                        cfg = { wind: 0.10, active: 0.12, rec: 0.18, dmgMin: 8, dmgMax: 12, stun: 0.32, knock: 300 };
                    } else {
                        cfg = { wind: 0.16, active: 0.16, rec: 0.26, dmgMin: 15, dmgMax: 20, stun: 0.36, knock: 460 };
                        this.specialCD = 3.0;
                    }

                    this.attack = { type, t: 0, hitDone: false, ...cfg };
                    this.state = type;
                    this.stateT = 0;
                    return true;
                }

                setBlock(on) {
                    if (!this.canAct()) { this.blocking = false; return; }
                    if (this.attack) { this.blocking = false; return; }
                    if (!this.onGround) { this.blocking = false; return; }
                    this.blocking = on;
                    if (on) {
                        this.state = "block";
                    } else {
                        if (this.state === "block") this.state = "idle";
                    }
                }

                takeHit(dmg, fromDir, stun, knock, isHeavy) {
                    if (this.ko) return;

                    // Basic directional block: must be blocking and facing attacker
                    let finalDmg = dmg;
                    const canBlockDir = this.blocking && (this.facing === fromDir);
                    if (canBlockDir) {
                        finalDmg = Math.max(1, Math.round(dmg * 0.30)); // 70% reduction
                    }

                    this.hp = Math.max(0, this.hp - finalDmg);

                    // apply reaction
                    if (!canBlockDir) {
                        this.stunT = Math.max(this.stunT, stun);
                        this.state = "hit";
                        this.stateT = 0;
                    }

                    // knockback
                    const kb = (canBlockDir ? knock * 0.28 : knock);
                    this.vx += (fromDir) * kb;
                    if (!this.onGround) {
                        this.vy += -120;
                    }

                    // flash intensity
                    this.flash = Math.min(1, this.flash + (isHeavy ? 0.9 : 0.6));

                    // KO
                    if (this.hp <= 0) {
                        this.ko = true;
                        this.state = "ko";
                        this.stateT = 0;
                        this.attack = null;
                        this.blocking = false;
                        this.stunT = 0;
                    }

                    return { blocked: canBlockDir, finalDmg };
                }

                computeAttackHitbox() {
                    if (!this.attack) return null;
                    const { type, t, wind, active } = this.attack;
                    if (t < wind || t > wind + active) return null;

                    const dir = this.facing;
                    const hb = this.hurtbox;
                    const midY = hb.y + hb.h * 0.52;

                    if (type === "punch") {
                        return { x: this.x + dir * 62, y: midY - 22, w: 58, h: 40, heavy: false };
                    }
                    if (type === "kick") {
                        return { x: this.x + dir * 66, y: hb.y + hb.h * 0.62 - 18, w: 62, h: 42, heavy: false };
                    }
                    // special
                    return { x: this.x + dir * 90, y: hb.y + hb.h * 0.44 - 38, w: 92, h: 74, heavy: true };
                }

                update(dt, input, world) {
                    // timers
                    this.stateT += dt;
                    if (this.stunT > 0) this.stunT -= dt;
                    if (this.specialCD > 0) this.specialCD = Math.max(0, this.specialCD - dt);
                    if (this.flash > 0) this.flash = Math.max(0, this.flash - dt * 2.6);

                    // If KO, let body fall and settle
                    if (this.ko) {
                        this.blocking = false;
                        // mild slide/fall
                        if (this.onGround) {
                            this.vx *= Math.pow(0.88, dt * 60);
                        }
                        this.vy += this.gravity * dt;
                        this.x += this.vx * dt;
                        this.y += this.vy * dt;
                        if (this.y >= world.floorY) {
                            this.y = world.floorY;
                            this.vy = 0;
                            this.onGround = true;
                        }
                        // clamp
                        this.x = clamp(this.x, world.left + 70, world.right - 70);
                        return;
                    }

                    if (this.victory) {
                        this.blocking = false;
                        this.vx *= Math.pow(0.82, dt * 60);
                        this.x += this.vx * dt;
                        this.x = clamp(this.x, world.left + 70, world.right - 70);
                        return;
                    }

                    // Attack progression
                    if (this.attack) {
                        this.attack.t += dt;
                        const total = this.attack.wind + this.attack.active + this.attack.rec;
                        if (this.attack.t >= total) {
                            this.attack = null;
                            if (this.state === "punch" || this.state === "kick" || this.state === "special") {
                                this.state = this.onGround ? "idle" : "jump";
                                this.stateT = 0;
                            }
                        }
                    }

                    // Movement control (only if can act)
                    let moveDir = 0;
                    let wantJump = false;
                    let wantPunch = false;
                    let wantKick = false;
                    let wantSpecial = false;
                    let wantBlock = false;

                    if (input) {
                        moveDir = (input.left ? -1 : 0) + (input.right ? 1 : 0);
                        wantJump = !!input.jump;
                        wantPunch = !!input.punch;
                        wantKick = !!input.kick;
                        wantSpecial = !!input.special;
                        wantBlock = !!input.block;
                    }

                    if (this.canAct()) {
                        // block (hold)
                        this.setBlock(wantBlock);

                        // attacks (press)
                        if (!this.blocking) {
                            if (wantSpecial) this.startAttack("special");
                            else if (wantKick) this.startAttack("kick");
                            else if (wantPunch) this.startAttack("punch");
                        }

                        // movement (no movement during attack/hit)
                        const locked = !!this.attack || this.stunT > 0 || this.blocking;
                        if (!locked) {
                            if (moveDir !== 0) {
                                this.vx += moveDir * this.moveAccel * dt;
                                this.vx = clamp(this.vx, -this.maxSpeed, this.maxSpeed);
                                this.state = this.onGround ? "walk" : "jump";
                            } else {
                                // friction
                                this.vx *= Math.pow(this.friction, dt * 60);
                                if (Math.abs(this.vx) < 10) this.vx = 0;
                                if (this.onGround) this.state = "idle";
                            }

                            if (wantJump && this.onGround) {
                                this.onGround = false;
                                this.vy = -this.jumpVel;
                                this.state = "jump";
                                this.stateT = 0;
                            }
                        } else {
                            // still apply some friction while blocked/attacking
                            this.vx *= Math.pow(0.90, dt * 60);
                        }
                    } else {
                        // stunned: dampen movement
                        this.vx *= Math.pow(0.90, dt * 60);
                        if (this.stunT > 0) this.state = "hit";
                    }

                    // gravity
                    this.vy += this.gravity * dt;

                    // integrate
                    this.x += this.vx * dt;
                    this.y += this.vy * dt;

                    // floor collision
                    if (this.y >= world.floorY) {
                        if (!this.onGround && this.vy > 250) {
                            world.onLand(this); // dust and thump
                        }
                        this.y = world.floorY;
                        this.vy = 0;
                        this.onGround = true;
                        if (!this.attack && !this.blocking && this.stunT <= 0) {
                            if (Math.abs(this.vx) > 35) this.state = "walk";
                            else this.state = "idle";
                        }
                    } else {
                        this.onGround = false;
                        if (!this.attack && !this.blocking) this.state = "jump";
                    }

                    // clamp arena bounds
                    this.x = clamp(this.x, world.left + 70, world.right - 70);

                    // update facing based on opponent if provided
                    if (world.opponent) {
                        const dir = Math.sign(world.opponent.x - this.x) || this.facing;
                        this.facing = dir;
                    }
                }

                // Stick-figure with cool silhouette + glow outline
                render(ctx, tGlobal) {
                    const glow = this.glow;
                    const dir = this.facing;

                    // base pose anchors
                    const footY = this.y;
                    const x = this.x;
                    const bob = Math.sin(tGlobal * 2.2 + (this.id * 1.3)) * 2.2;

                    // Determine animation phase
                    const speed = Math.abs(this.vx);
                    const walkPhase = tGlobal * 9.5 + x * 0.01;
                    const walkAmp = clamp(speed / 420, 0, 1);

                    const attackType = this.attack?.type || null;
                    const at = this.attack ? this.attack.t : 0;
                    const total = this.attack ? (this.attack.wind + this.attack.active + this.attack.rec) : 1;
                    const ap = this.attack ? clamp(at / total, 0, 1) : 0;

                    // angles (radians)
                    let torsoLean = 0;
                    let armFront = -0.8, armBack = 0.8;
                    let legFront = 0.7, legBack = -0.6;
                    let kneeFront = 0.9, kneeBack = 0.8;
                    let crouch = 0;

                    if (this.state === "walk") {
                        torsoLean = -dir * 0.06 * walkAmp;
                        const s = Math.sin(walkPhase) * walkAmp;
                        legFront = 0.9 * s;
                        legBack = -0.9 * s;
                        kneeFront = 0.8 + 0.25 * Math.max(0, -s);
                        kneeBack = 0.8 + 0.25 * Math.max(0, s);
                        armFront = -0.9 * s * 0.8;
                        armBack = 0.9 * s * 0.8;
                    }

                    if (this.state === "jump") {
                        crouch = 0.10;
                        torsoLean = -dir * 0.05;
                        armFront = -0.35;
                        armBack = 0.35;
                        legFront = 0.35;
                        legBack = -0.35;
                    }

                    if (this.state === "block") {
                        crouch = 0.16;
                        torsoLean = -dir * 0.03;
                        armFront = -0.15;
                        armBack = 0.15;
                    }

                    if (this.state === "hit") {
                        torsoLean = -dir * 0.20;
                        armFront = -0.45;
                        armBack = 0.65;
                    }

                    if (attackType) {
                        const ease = (p) => (p < 0.5 ? 2 * p * p : 1 - Math.pow(-2 * p + 2, 2) / 2);
                        const p = ease(ap);
                        if (attackType === "punch") {
                            torsoLean = -dir * (0.08 + 0.10 * p);
                            armFront = -0.25 - 1.15 * p; // extend
                            armBack = 0.55;
                            legFront = 0.15;
                            legBack = -0.20;
                        } else if (attackType === "kick") {
                            torsoLean = -dir * (0.12 + 0.14 * p);
                            legFront = 0.10 + 1.15 * p; // kick out
                            kneeFront = 0.55;
                            armFront = -0.18;
                            armBack = 0.42;
                        } else { // special
                            torsoLean = -dir * (0.16 + 0.22 * p);
                            armFront = -0.35 - 1.05 * p;
                            armBack = 0.35 + 0.55 * p;
                            legFront = 0.20 + 0.85 * p;
                            legBack = -0.20 - 0.35 * p;
                        }
                    }

                    // KO / Victory pose
                    if (this.state === "ko") {
                        torsoLean = -dir * 1.05;
                        crouch = 0.30;
                        armFront = -1.2;
                        armBack = 1.2;
                    }
                    if (this.state === "victory") {
                        torsoLean = -dir * 0.08;
                        armFront = -1.35;
                        armBack = 0.20;
                        legFront = 0.15;
                        legBack = -0.15;
                    }

                    // key points
                    const scale = 1.0;
                    const hip = { x: x, y: footY - (20 - bob) - crouch * 45 };
                    const shoulder = { x: hip.x + dir * (6 + torsoLean * 35), y: hip.y - 78 };
                    const head = { x: shoulder.x + dir * (10 + torsoLean * 15), y: shoulder.y - 38 };

                    // segment lengths
                    const upperArm = 36, lowerArm = 34;
                    const upperLeg = 44, lowerLeg = 48;

                    // helper to compute joint chain
                    function chain(base, a1, l1, a2, l2) {
                        const p1 = { x: base.x + Math.cos(a1) * l1, y: base.y + Math.sin(a1) * l1 };
                        const p2 = { x: p1.x + Math.cos(a2) * l2, y: p1.y + Math.sin(a2) * l2 };
                        return { p1, p2 };
                    }

                    // angles are relative to facing
                    const baseArmAngle = dir > 0 ? Math.PI : 0;
                    const baseLegAngle = dir > 0 ? Math.PI / 2 : Math.PI / 2; // legs mainly downward

                    // Arms: shoulder -> elbow -> hand
                    const frontArmA1 = -Math.PI / 2 + armFront + torsoLean;
                    const frontArmA2 = frontArmA1 + 0.55;
                    const backArmA1 = -Math.PI / 2 + armBack + torsoLean;
                    const backArmA2 = backArmA1 + 0.55;

                    const fa = chain(shoulder, frontArmA1, upperArm, frontArmA2, lowerArm);
                    const ba = chain(shoulder, backArmA1, upperArm, backArmA2, lowerArm);

                    // Legs: hip -> knee -> foot
                    const frontLegA1 = Math.PI / 2 + legFront * 0.55;
                    const frontLegA2 = frontLegA1 + kneeFront;
                    const backLegA1 = Math.PI / 2 + legBack * 0.55;
                    const backLegA2 = backLegA1 + kneeBack;

                    const fl = chain(hip, frontLegA1, upperLeg, frontLegA2, lowerLeg);
                    const bl = chain(hip, backLegA1, upperLeg, backLegA2, lowerLeg);

                    // Body path drawing
                    const lw = 14 * scale;
                    const lw2 = 18 * scale;

                    // shadow silhouette + glow outline trick:
                    // stroke in black with shadow blur = glow color -> produces glow outline around silhouette.
                    const drawFigure = (withGlow) => {
                        ctx.lineCap = "round";
                        ctx.lineJoin = "round";

                        ctx.beginPath();
                        // spine/torso
                        ctx.moveTo(hip.x, hip.y);
                        ctx.lineTo(shoulder.x, shoulder.y);

                        // arms
                        ctx.moveTo(shoulder.x, shoulder.y);
                        ctx.lineTo(fa.p1.x, fa.p1.y);
                        ctx.lineTo(fa.p2.x, fa.p2.y);

                        ctx.moveTo(shoulder.x, shoulder.y);
                        ctx.lineTo(ba.p1.x, ba.p1.y);
                        ctx.lineTo(ba.p2.x, ba.p2.y);

                        // legs
                        ctx.moveTo(hip.x, hip.y);
                        ctx.lineTo(fl.p1.x, fl.p1.y);
                        ctx.lineTo(fl.p2.x, fl.p2.y);

                        ctx.moveTo(hip.x, hip.y);
                        ctx.lineTo(bl.p1.x, bl.p1.y);
                        ctx.lineTo(bl.p2.x, bl.p2.y);

                        // optional weapon-ish accent on special
                        if (attackType === "special") {
                            const p = { x: this.x + dir * 78, y: this.y - 112 };
                            ctx.moveTo(fa.p2.x, fa.p2.y);
                            ctx.lineTo(p.x, p.y);
                        }

                        ctx.stroke();

                        // head
                        ctx.beginPath();
                        ctx.arc(head.x, head.y, 18 * scale, 0, Math.PI * 2);
                        ctx.fill();
                    };

                    // Render
                    ctx.save();

                    // slight squash on landing
                    const landSquash = this.onGround ? 1 - Math.min(0.06, Math.abs(this.vx) / 800) : 1.0;
                    ctx.translate(0, 0);
                    ctx.scale(1, landSquash);

                    // hit flash (white rim)
                    if (this.flash > 0.01) {
                        ctx.save();
                        ctx.globalAlpha = this.flash * 0.45;
                        ctx.strokeStyle = "rgba(255,255,255,.85)";
                        ctx.fillStyle = "rgba(255,255,255,.75)";
                        ctx.shadowColor = "rgba(255,255,255,.65)";
                        ctx.shadowBlur = 26;
                        ctx.lineWidth = lw2;
                        drawFigure(true);
                        ctx.restore();
                    }

                    // glow pass
                    ctx.strokeStyle = this.core;
                    ctx.fillStyle = this.core;
                    ctx.shadowColor = glow;
                    ctx.shadowBlur = 28;
                    ctx.lineWidth = lw2;
                    drawFigure(true);

                    // crisp pass
                    ctx.shadowBlur = 0;
                    ctx.lineWidth = lw;
                    drawFigure(false);

                    ctx.restore();
                }
            }

            // -----------------------------
            // AI Controller
            // -----------------------------
            class AIController {
                constructor() {
                    this.reaction = 0.28;
                    this.timer = 0;
                    this.intent = { left: false, right: false, jump: false, punch: false, kick: false, special: false, block: false };
                    this.nextThinkAt = 0;
                    this.lastPlayerAttackAt = -999;
                    this.blockHoldT = 0;
                    this.difficulty = 1;
                }

                setDifficulty(round) {
                    // Difficulty ramps each round
                    this.difficulty = 1 + (round - 1) * 0.55; // 1.0, 1.55, 2.1
                }

                notifyPlayerAttack() {
                    this.lastPlayerAttackAt = now();
                }

                update(dt, enemy, player, game) {
                    this.timer += dt;

                    // reaction delay feels human: 200-500ms (lower with difficulty)
                    const baseDelay = rand(0.20, 0.50);
                    const delay = clamp(baseDelay - (this.difficulty - 1) * 0.06, 0.16, 0.50);

                    if (this.timer < this.nextThinkAt) return this.intent;

                    this.nextThinkAt = this.timer + delay;

                    // reset intent (press-type actions only for this frame)
                    this.intent.punch = false;
                    this.intent.kick = false;
                    this.intent.special = false;
                    this.intent.jump = false;

                    // movement intent
                    const dx = player.x - enemy.x;
                    const dist = Math.abs(dx);

                    // desired fighting distance
                    const desired = lerp(165, 135, clamp((this.difficulty - 1) / 1.2, 0, 1));
                    const tooClose = dist < desired - 25;
                    const tooFar = dist > desired + 50;

                    this.intent.left = false;
                    this.intent.right = false;

                    // Can't walk through player: push logic handled by game, but AI avoids
                    if (!enemy.attack && enemy.stunT <= 0 && !enemy.blocking) {
                        if (tooFar) {
                            if (dx > 0) this.intent.right = true; else this.intent.left = true;
                        } else if (tooClose) {
                            // backstep
                            if (dx > 0) this.intent.left = true; else this.intent.right = true;
                            // occasional hop out
                            if (enemy.onGround && Math.random() < 0.08 * this.difficulty) this.intent.jump = true;
                        } else {
                            // micro-adjust
                            if (Math.random() < 0.25) {
                                if (dx > 0) this.intent.right = true;
                                else this.intent.left = true;
                            }
                        }
                    }

                    // blocking behavior: 20% chance when player attacks (higher with difficulty)
                    const playerIsThreatening = (now() - this.lastPlayerAttackAt) < 420;
                    const blockChance = clamp(0.20 + (this.difficulty - 1) * 0.08, 0.20, 0.35);
                    if (playerIsThreatening && enemy.onGround && !enemy.attack && enemy.stunT <= 0) {
                        if (Math.random() < blockChance) {
                            this.intent.block = true;
                            this.blockHoldT = rand(0.22, 0.45);
                        }
                    }

                    if (this.blockHoldT > 0) {
                        this.blockHoldT -= dt;
                        if (this.blockHoldT <= 0) this.intent.block = false;
                    } else {
                        // let go block occasionally
                        if (this.intent.block && Math.random() < 0.15) this.intent.block = false;
                    }

                    // attack decisions
                    if (game.state !== "FIGHTING") return this.intent;
                    if (!enemy.canAct()) return this.intent;
                    if (enemy.blocking) return this.intent;
                    if (enemy.attack) return this.intent;

                    // choose attack when in range
                    const inRange = dist < 220 && dist > 95;
                    const veryClose = dist <= 115;

                    if (inRange || veryClose) {
                        const aggression = clamp(0.42 + (this.difficulty - 1) * 0.12, 0.42, 0.65);
                        if (Math.random() < aggression) {
                            const canSpecial = enemy.specialCD <= 0 && Math.random() < (0.20 + (this.difficulty - 1) * 0.08);
                            if (canSpecial) {
                                this.intent.special = true;
                            } else {
                                // mix punches and kicks
                                const kickBias = clamp(0.45 + (this.difficulty - 1) * 0.08, 0.45, 0.60);
                                if (Math.random() < kickBias) this.intent.kick = true;
                                else this.intent.punch = true;
                            }
                        }
                    }

                    return this.intent;
                }
            }

            // -----------------------------
            // UI
            // -----------------------------
            class UI {
                constructor() {
                    this.p1Fill = document.getElementById("p1Fill");
                    this.p2Fill = document.getElementById("p2Fill");
                    this.timerEl = document.getElementById("timer");
                    this.comboWrap = document.getElementById("combo");
                    this.comboCount = document.getElementById("comboCount");
                    this.banner = document.getElementById("banner");
                    this.flash = document.getElementById("flash");
                    this.menu = document.getElementById("menu");
                    this.gameOver = document.getElementById("gameOver");
                    this.gameOverTitle = document.getElementById("gameOverTitle");
                    this.gameOverSub = document.getElementById("gameOverSub");
                    this.playAgain = document.getElementById("playAgain");
                    this.backMenu = document.getElementById("backMenu");
                    this.dots = [document.getElementById("r1"), document.getElementById("r2"), document.getElementById("r3")];

                    this.flashA = 0;
                    this.bannerLock = false;

                    this.playAgain.addEventListener("click", () => window.__GAME__?.restartFromOver());
                    this.backMenu.addEventListener("click", () => window.__GAME__?.backToMenu());
                }

                setMenuVisible(v) {
                    this.menu.classList.toggle("hide", !v);
                }
                setGameOverVisible(v) {
                    this.gameOver.classList.toggle("hide", !v);
                }

                updateHealth(p1, p2) {
                    const f1 = clamp(p1.hp / p1.maxHp, 0, 1);
                    const f2 = clamp(p2.hp / p2.maxHp, 0, 1);
                    this.p1Fill.style.transform = `scaleX(${f1})`;
                    // reverse direction visually for p2
                    this.p2Fill.style.transformOrigin = "right center";
                    this.p2Fill.style.transform = `scaleX(${f2})`;
                }

                updateTimer(seconds) {
                    this.timerEl.textContent = String(Math.ceil(seconds)).padStart(2, "0");
                    // little urgency glow
                    if (seconds <= 10) {
                        this.timerEl.style.boxShadow = "0 12px 40px rgba(0,0,0,.35), 0 0 35px rgba(255,60,60,.18)";
                        this.timerEl.style.textShadow = "0 0 18px rgba(255,80,80,.25)";
                    } else {
                        this.timerEl.style.boxShadow = "0 12px 40px rgba(0,0,0,.35)";
                        this.timerEl.style.textShadow = "0 0 18px rgba(160,190,255,.25)";
                    }
                }

                setRoundDots(p1Wins, p2Wins) {
                    const wins = [
                        ...(Array(p1Wins).fill("p1")),
                        ...(Array(p2Wins).fill("p2")),
                    ];
                    for (let i = 0; i < 3; i++) {
                        this.dots[i].classList.remove("winP1", "winP2");
                        if (wins[i] === "p1") this.dots[i].classList.add("winP1");
                        if (wins[i] === "p2") this.dots[i].classList.add("winP2");
                    }
                }

                showCombo(n) {
                    if (n <= 1) {
                        this.comboWrap.classList.remove("show");
                        return;
                    }
                    this.comboCount.textContent = `x${n}`;
                    this.comboWrap.classList.add("show");
                }

                hideCombo() {
                    this.comboWrap.classList.remove("show");
                }

                flashScreen(amount = 0.35) {
                    this.flashA = Math.max(this.flashA, amount);
                }

                update(dt) {
                    if (this.flashA > 0) {
                        this.flashA = Math.max(0, this.flashA - dt * 2.4);
                        this.flash.style.opacity = String(this.flashA);
                    } else {
                        this.flash.style.opacity = "0";
                    }
                }

                announce(text, opts = {}) {
                    if (this.bannerLock) return;
                    const div = document.createElement("div");
                    div.className = "bannerText" + (opts.red ? " redGlow" : "");
                    div.textContent = text;
                    this.banner.appendChild(div);
                    // auto-remove after animation
                    setTimeout(() => {
                        div.remove();
                    }, 980);
                }

                setGameOverText(win) {
                    this.gameOverTitle.textContent = win ? "YOU WIN" : "DEFEAT";
                    this.gameOverSub.textContent = win ? "Victory is yours. Best of 3 complete." : "You were outplayed. Best of 3 complete.";
                    // tweak glow
                    this.gameOverTitle.style.textShadow = win
                        ? "0 0 24px rgba(0,247,255,.22), 0 0 60px rgba(0,247,255,.10), 0 18px 90px rgba(0,0,0,.60)"
                        : "0 0 24px rgba(255,0,64,.22), 0 0 60px rgba(255,0,64,.10), 0 18px 90px rgba(0,0,0,.60)";
                }
            }

            // -----------------------------
            // Input
            // -----------------------------
            class Input {
                constructor() {
                    this.down = new Set();
                    this.pressed = new Set();
                    this.consume = new Set(); // consumed pressed keys

                    window.addEventListener("keydown", (e) => {
                        // prevent page scroll
                        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key)) e.preventDefault();

                        const k = e.key.toLowerCase();
                        if (!this.down.has(k)) this.pressed.add(k);
                        this.down.add(k);

                        // Audio unlock on first input
                        window.__GAME__?.sound.ensure();
                    }, { passive: false });

                    window.addEventListener("keyup", (e) => {
                        const k = e.key.toLowerCase();
                        this.down.delete(k);
                    });
                }

                isDown(k) { return this.down.has(k); }

                // "pressed once" in this frame
                wasPressed(k) {
                    if (!this.pressed.has(k)) return false;
                    if (this.consume.has(k)) return false;
                    this.consume.add(k);
                    return true;
                }

                endFrame() {
                    this.pressed.clear();
                    this.consume.clear();
                }

                get player1() {
                    return {
                        left: this.isDown("a"),
                        right: this.isDown("d"),
                        jump: this.wasPressed("w"),
                        punch: this.wasPressed("j"),
                        kick: this.wasPressed("k"),
                        special: this.wasPressed("l"),
                        block: this.isDown("i"),
                        enter: this.wasPressed("enter"),
                    };
                }
            }

            // -----------------------------
            // World / Game
            // -----------------------------
            class Game {
                constructor(canvas) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext("2d", { alpha: true, desynchronized: true });
                    this.dpr = Math.max(1, Math.min(2.25, window.devicePixelRatio || 1));

                    // world coords (16:9)
                    this.W = 1280;
                    this.H = 720;
                    this.floorY = 580;

                    this.left = 80;
                    this.right = this.W - 80;

                    this.state = "MENU"; // MENU → ROUND_INTRO → FIGHTING → ROUND_END → GAME_OVER
                    this.round = 1;
                    this.bestOf = 3;
                    this.p1Wins = 0;
                    this.p2Wins = 0;

                    this.roundTime = 60;
                    this.timer = this.roundTime;

                    this.sound = new SoundManager();
                    this.ui = new UI();
                    this.input = new Input();
                    this.ai = new AIController();

                    // Entities
                    this.player = new Fighter({ id: 1, name: "PLAYER", glow: "rgba(0,247,255,1)", x: 380, y: this.floorY, facing: 1, isAI: false });
                    this.enemy = new Fighter({ id: 2, name: "ENEMY", glow: "rgba(255,0,64,1)", x: 900, y: this.floorY, facing: -1, isAI: true });

                    this.particles = [];
                    this.texts = [];

                    // camera / effects
                    this.shakeT = 0;
                    this.shakeMag = 0;
                    this.slowMoT = 0;
                    this.timeScale = 1;

                    // ambient particles spawn
                    this.ambT = 0;

                    // canvas scale handling
                    this.resize();
                    window.addEventListener("resize", () => this.resize());

                    // Buttons already wired in UI
                    this.ui.setMenuVisible(true);
                    this.ui.setGameOverVisible(false);

                    // expose for UI buttons + input unlock
                    window.__GAME__ = this;

                    this.last = now();
                    requestAnimationFrame(() => this.loop());
                }

                resize() {
                    const rect = this.canvas.getBoundingClientRect();
                    const cssW = rect.width;
                    const cssH = rect.height;
                    this.canvas.width = Math.floor(cssW * this.dpr);
                    this.canvas.height = Math.floor(cssH * this.dpr);
                    this.scale = Math.min(this.canvas.width / this.W, this.canvas.height / this.H);
                    this.offsetX = (this.canvas.width - this.W * this.scale) / 2;
                    this.offsetY = (this.canvas.height - this.H * this.scale) / 2;
                }

                restartFromOver() {
                    this.p1Wins = 0;
                    this.p2Wins = 0;
                    this.round = 1;
                    this.state = "ROUND_INTRO";
                    this.ui.setGameOverVisible(false);
                    this.ui.setMenuVisible(false);
                    this.startRound(true);
                }

                backToMenu() {
                    this.state = "MENU";
                    this.ui.setGameOverVisible(false);
                    this.ui.setMenuVisible(true);
                    this.ui.hideCombo();
                    this.ui.updateTimer(this.roundTime);
                    this.ui.setRoundDots(0, 0);
                    // reset fighters for visuals
                    this.player.resetForRound(380, 1, this.floorY);
                    this.enemy.resetForRound(900, -1, this.floorY);
                    this.particles.length = 0;
                    this.texts.length = 0;
                }

                startRound(playIntroSfx) {
                    this.timer = this.roundTime;
                    this.player.resetForRound(380, 1, this.floorY);
                    this.enemy.resetForRound(900, -1, this.floorY);
                    this.ai.setDifficulty(this.round);

                    this.particles.length = 0;
                    this.texts.length = 0;

                    this.ui.setRoundDots(this.p1Wins, this.p2Wins);
                    this.ui.updateHealth(this.player, this.enemy);
                    this.ui.updateTimer(this.timer);

                    // flow: ROUND n → FIGHT!
                    this.state = "ROUND_INTRO";
                    this.ui.bannerLock = true;
                    this.ui.announce(`ROUND ${this.round}`);
                    if (playIntroSfx) this.sound.roundStart();

                    setTimeout(() => {
                        this.ui.announce("FIGHT!");
                        this.ui.bannerLock = false;
                        this.state = "FIGHTING";
                    }, 900);
                }

                endRound(winner) { // winner: "p1" | "p2" | "draw"
                    this.state = "ROUND_END";
                    this.ui.hideCombo();

                    const isKO = (this.player.ko || this.enemy.ko);
                    if (isKO) this.ui.announce("K.O!", { red: winner === "p2" });

                    // award
                    if (winner === "p1") this.p1Wins++;
                    if (winner === "p2") this.p2Wins++;

                    this.ui.setRoundDots(this.p1Wins, this.p2Wins);

                    // victory pose
                    if (winner === "p1") {
                        this.player.victory = true; this.player.state = "victory"; this.player.stateT = 0;
                    } else if (winner === "p2") {
                        this.enemy.victory = true; this.enemy.state = "victory"; this.enemy.stateT = 0;
                    }

                    // decide game over
                    const need = Math.ceil(this.bestOf / 2); // 2
                    const done = (this.p1Wins >= need) || (this.p2Wins >= need);

                    setTimeout(() => {
                        if (done) {
                            const win = this.p1Wins > this.p2Wins;
                            this.ui.setGameOverText(win);
                            this.ui.setGameOverVisible(true);
                            this.state = "GAME_OVER";
                        } else {
                            // next round
                            this.round++;
                            this.startRound(false);
                        }
                    }, 1200);
                }

                applyShake(mag, time) {
                    this.shakeMag = Math.max(this.shakeMag, mag);
                    this.shakeT = Math.max(this.shakeT, time);
                }

                slowMo(time = 0.55) {
                    this.slowMoT = Math.max(this.slowMoT, time);
                    this.timeScale = 0.25;
                }

                spawnHitSparks(x, y, color, heavy) {
                    const n = heavy ? 18 : 12;
                    for (let i = 0; i < n; i++) {
                        const a = rand(-Math.PI, Math.PI);
                        const sp = rand(120, heavy ? 520 : 380);
                        const p = new Particle(
                            x + rand(-4, 4),
                            y + rand(-4, 4),
                            Math.cos(a) * sp,
                            Math.sin(a) * sp,
                            rand(0.25, heavy ? 0.70 : 0.55),
                            rand(1.5, heavy ? 3.2 : 2.6),
                            color,
                            color
                        );
                        p.drag = 0.90;
                        p.gravity = 900;
                        this.particles.push(p);
                    }
                }

                spawnSpecialTrail(fighter) {
                    // arc trail around hand
                    const hb = fighter.computeAttackHitbox();
                    if (!hb) return;
                    const cx = hb.x + hb.w / 2;
                    const cy = hb.y + hb.h / 2;
                    for (let i = 0; i < 3; i++) {
                        const p = new Particle(
                            cx + rand(-14, 14),
                            cy + rand(-14, 14),
                            rand(-60, 60) + fighter.facing * rand(40, 140),
                            rand(-120, 120),
                            rand(0.25, 0.55),
                            rand(2.0, 3.4),
                            "rgba(255,255,255,.55)",
                            fighter.glow
                        );
                        p.drag = 0.88;
                        p.gravity = rand(120, 260);
                        this.particles.push(p);
                    }
                }

                onLand(fighter) {
                    // ground dust
                    const c = fighter.isAI ? "rgba(255,0,64,.22)" : "rgba(0,247,255,.22)";
                    for (let i = 0; i < 8; i++) {
                        const p = new Particle(
                            fighter.x + rand(-18, 18),
                            this.floorY - 6 + rand(-2, 2),
                            rand(-120, 120),
                            rand(-90, -220),
                            rand(0.25, 0.48),
                            rand(2.0, 3.2),
                            "rgba(255,255,255,.08)",
                            c
                        );
                        p.drag = 0.90;
                        p.gravity = 720;
                        this.particles.push(p);
                    }
                }

                ambient(dt) {
                    this.ambT += dt;
                    if (this.ambT > 0.03) {
                        this.ambT = 0;
                        const y = rand(90, this.floorY - 80);
                        const p = new Particle(
                            rand(this.left, this.right),
                            y,
                            rand(-12, 18),
                            rand(-6, 10),
                            rand(2.8, 6.0),
                            rand(0.8, 1.6),
                            "rgba(255,255,255,.05)",
                            "rgba(120,170,255,.20)"
                        );
                        p.drag = 0.995;
                        p.gravity = 0;
                        this.particles.push(p);
                    }
                }

                update(dtRaw) {
                    // time scaling / slowmo
                    if (this.slowMoT > 0) {
                        this.slowMoT -= dtRaw;
                        // ease out of slowmo
                        const p = clamp(1 - (this.slowMoT / 0.55), 0, 1);
                        this.timeScale = lerp(0.25, 1.0, p);
                        if (this.slowMoT <= 0) this.timeScale = 1;
                    } else {
                        this.timeScale = 1;
                    }

                    const dt = dtRaw * this.timeScale;

                    // input & state transitions
                    const in1 = this.input.player1;

                    if (this.state === "MENU") {
                        this.ui.setMenuVisible(true);
                        if (in1.enter) {
                            this.ui.setMenuVisible(false);
                            this.p1Wins = 0;
                            this.p2Wins = 0;
                            this.round = 1;
                            this.startRound(true);
                        }
                    }

                    if (this.state === "FIGHTING") {
                        this.timer -= dt;
                        if (this.timer <= 0) {
                            this.timer = 0;
                            // decide by HP; if tie -> sudden death 15s
                            if (this.player.hp === this.enemy.hp) {
                                this.ui.announce("SUDDEN DEATH");
                                this.timer = 15;
                            } else {
                                const winner = (this.player.hp > this.enemy.hp) ? "p1" : "p2";
                                this.endRound(winner);
                            }
                        }
                    }

                    // Update UI
                    this.ui.updateTimer(this.timer);
                    this.ui.update(dt);

                    // update ambient particles always
                    this.ambient(dtRaw);

                    // world context for fighters
                    const worldP1 = { floorY: this.floorY, left: this.left, right: this.right, opponent: this.enemy, onLand: (f) => this.onLand(f) };
                    const worldP2 = { floorY: this.floorY, left: this.left, right: this.right, opponent: this.player, onLand: (f) => this.onLand(f) };

                    // AI intent
                    let aiInput = null;
                    if (this.state === "FIGHTING") {
                        aiInput = this.ai.update(dtRaw, this.enemy, this.player, this);
                    } else {
                        aiInput = { left: false, right: false, jump: false, punch: false, kick: false, special: false, block: false };
                    }

                    // Notify AI about player attack press (for block reaction)
                    if (in1.punch || in1.kick || in1.special) {
                        this.ai.notifyPlayerAttack();
                    }

                    // Update fighters
                    this.player.update(dt, in1, worldP1);
                    this.enemy.update(dt, aiInput, worldP2);

                    // Prevent walking through each other
                    const minDist = 118;
                    const dx = this.enemy.x - this.player.x;
                    const dist = Math.abs(dx);
                    if (dist < minDist) {
                        const push = (minDist - dist) * 0.5;
                        const dir = Math.sign(dx) || 1;
                        this.player.x -= dir * push;
                        this.enemy.x += dir * push;
                        this.player.x = clamp(this.player.x, this.left + 70, this.right - 70);
                        this.enemy.x = clamp(this.enemy.x, this.left + 70, this.right - 70);
                    }

                    // Combat resolution only while fighting
                    if (this.state === "FIGHTING") {
                        this.resolveAttacks();
                    }

                    // Update particles / texts
                    for (const p of this.particles) p.update(dt);
                    this.particles = this.particles.filter(p => !p.dead);

                    for (const ft of this.texts) ft.update(dt);
                    this.texts = this.texts.filter(t => !t.dead);

                    // screen shake decay
                    if (this.shakeT > 0) {
                        this.shakeT -= dtRaw;
                        if (this.shakeT <= 0) {
                            this.shakeT = 0;
                            this.shakeMag = 0;
                        } else {
                            this.shakeMag *= Math.pow(0.86, dtRaw * 60);
                        }
                    }

                    this.input.endFrame();
                }

                resolveAttacks() {
                    // p1 hits p2
                    this._resolveHit(this.player, this.enemy, "rgba(0,247,255,1)");
                    // p2 hits p1
                    this._resolveHit(this.enemy, this.player, "rgba(255,0,64,1)");

                    // update health UI
                    this.ui.updateHealth(this.player, this.enemy);

                    // if round ends (KO)
                    if (this.player.ko && !this.enemy.ko) {
                        // dramatic slowmo & KO sound on final hit
                        if (this.state === "FIGHTING") {
                            this.sound.ko();
                            this.slowMo(0.55);
                            this.spawnKOExplosion(this.player.x, this.player.y - 90, "rgba(255,0,64,1)");
                            this.endRound("p2");
                        }
                    } else if (this.enemy.ko && !this.player.ko) {
                        if (this.state === "FIGHTING") {
                            this.sound.ko();
                            this.slowMo(0.55);
                            this.spawnKOExplosion(this.enemy.x, this.enemy.y - 90, "rgba(0,247,255,1)");
                            this.endRound("p1");
                        }
                    }
                }

                spawnKOExplosion(x, y, glow) {
                    for (let i = 0; i < 40; i++) {
                        const a = rand(-Math.PI, Math.PI);
                        const sp = rand(160, 780);
                        const p = new Particle(
                            x + rand(-6, 6),
                            y + rand(-6, 6),
                            Math.cos(a) * sp,
                            Math.sin(a) * sp,
                            rand(0.45, 1.1),
                            rand(2.2, 4.6),
                            "rgba(255,255,255,.10)",
                            glow
                        );
                        p.drag = 0.88;
                        p.gravity = 900;
                        this.particles.push(p);
                    }
                    this.ui.flashScreen(0.45);
                    this.applyShake(18, 0.35);
                }

                _resolveHit(attacker, defender, color) {
                    if (!attacker.attack || attacker.attack.hitDone) return;
                    const hb = attacker.computeAttackHitbox();
                    if (!hb) return;
                    const db = defender.hurtbox;

                    if (rectsOverlap({ x: hb.x, y: hb.y, w: hb.w, h: hb.h }, db)) {
                        attacker.attack.hitDone = true;

                        const dmg = randi(attacker.attack.dmgMin, attacker.attack.dmgMax);
                        const fromDir = attacker.facing;
                        const heavy = hb.heavy;

                        const res = defender.takeHit(dmg, fromDir, attacker.attack.stun, attacker.attack.knock, heavy);

                        // Sound & effects
                        if (res.blocked) {
                            this.sound.block();
                        } else {
                            if (attacker.attack.type === "punch") this.sound.punch();
                            else if (attacker.attack.type === "kick") this.sound.kick();
                            else this.sound.special();
                            this.sound.hit();
                        }

                        // Combo system (1s window)
                        const t = now();
                        if (t - attacker.lastComboHitAt <= 1000) attacker.comboCount++;
                        else attacker.comboCount = 1;
                        attacker.lastComboHitAt = t;

                        // Combo multiplier (visual only, but we can slightly buff)
                        const mult = 1 + Math.min(0.18 * (attacker.comboCount - 1), 0.6);
                        if (!res.blocked) {
                            // apply extra chip as "combo momentum" (tiny)
                            const extra = Math.floor((dmg * mult) - dmg);
                            if (extra > 0) {
                                defender.hp = Math.max(0, defender.hp - extra);
                            }
                        }

                        // UI combo only for player hits
                        if (attacker === this.player) {
                            this.ui.showCombo(attacker.comboCount);
                            // auto-hide after a bit of no hits
                            clearTimeout(this._comboTimeout);
                            this._comboTimeout = setTimeout(() => this.ui.hideCombo(), 850);
                        }

                        // Particles + texts
                        const hitX = clamp(hb.x + hb.w / 2, db.x, db.x + db.w);
                        const hitY = clamp(hb.y + hb.h / 2, db.y, db.y + db.h);

                        if (!res.blocked) {
                            this.spawnHitSparks(hitX, hitY, color, heavy);
                            if (attacker.attack.type === "special") {
                                this.spawnSpecialTrail(attacker);
                                this.ui.flashScreen(heavy ? 0.35 : 0.22);
                            } else {
                                this.ui.flashScreen(0.18);
                            }
                            this.applyShake(heavy ? 14 : 8, heavy ? 0.24 : 0.16);
                            this.texts.push(new FloatingText(hitX + rand(-10, 10), hitY - 10, `-${res.finalDmg}`, "rgba(255,255,255,.92)", 0.75));
                        } else {
                            // block sparks
                            this.spawnHitSparks(hitX, hitY, "rgba(255,255,255,.35)", false);
                            this.texts.push(new FloatingText(hitX + rand(-10, 10), hitY - 10, `${res.finalDmg}`, "rgba(180,200,255,.75)", 0.65));
                        }
                    }
                }

                render(t) {
                    const ctx = this.ctx;
                    const gTime = t / 1000;

                    // fit world into canvas
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                    ctx.translate(this.offsetX, this.offsetY);
                    ctx.scale(this.scale, this.scale);

                    // screen shake
                    if (this.shakeT > 0) {
                        const mag = this.shakeMag;
                        ctx.translate(rand(-mag, mag), rand(-mag * 0.7, mag * 0.7));
                    }

                    // Background (canvas layer to complement CSS)
                    this.drawBackground(ctx, gTime);

                    // Floor line
                    this.drawFloor(ctx, gTime);

                    // Fighters (draw farthest first)
                    if (this.player.x < this.enemy.x) {
                        this.player.render(ctx, gTime);
                        this.enemy.render(ctx, gTime);
                    } else {
                        this.enemy.render(ctx, gTime);
                        this.player.render(ctx, gTime);
                    }

                    // Particles
                    for (const p of this.particles) p.render(ctx);

                    // Floating texts
                    for (const ft of this.texts) ft.render(ctx);

                    // Debug hitboxes (disabled)
                    // this.debugHitboxes(ctx);
                }

                drawBackground(ctx, time) {
                    // deep gradient
                    const grd = ctx.createLinearGradient(0, 0, 0, this.H);
                    grd.addColorStop(0, "rgba(10,10,10,0.30)");
                    grd.addColorStop(0.55, "rgba(26,26,46,0.24)");
                    grd.addColorStop(1, "rgba(0,0,0,0.30)");
                    ctx.fillStyle = grd;
                    ctx.fillRect(0, 0, this.W, this.H);

                    // distant hills
                    ctx.save();
                    ctx.globalAlpha = 0.75;
                    ctx.fillStyle = "rgba(0,0,0,.55)";
                    ctx.beginPath();
                    ctx.moveTo(0, this.floorY - 190);
                    for (let x = 0; x <= this.W; x += 120) {
                        const y = (this.floorY - 190) + Math.sin(time * 0.25 + x * 0.012) * 14 + Math.sin(time * 0.11 + x * 0.02) * 8;
                        ctx.lineTo(x, y);
                    }
                    ctx.lineTo(this.W, this.H);
                    ctx.lineTo(0, this.H);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();

                    // subtle god rays
                    ctx.save();
                    ctx.globalAlpha = 0.12;
                    ctx.fillStyle = "rgba(120,170,255,.22)";
                    for (let i = 0; i < 6; i++) {
                        const x = 860 + i * 70;
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x + 120, 0);
                        ctx.lineTo(x - 140, this.floorY);
                        ctx.lineTo(x - 260, this.floorY);
                        ctx.closePath();
                        ctx.fill();
                    }
                    ctx.restore();
                }

                drawFloor(ctx, time) {
                    // arena floor
                    const y = this.floorY + 4;
                    ctx.save();

                    // ground plane gradient
                    const grd = ctx.createLinearGradient(0, y, 0, this.H);
                    grd.addColorStop(0, "rgba(0,0,0,.25)");
                    grd.addColorStop(0.35, "rgba(0,0,0,.60)");
                    grd.addColorStop(1, "rgba(0,0,0,.85)");
                    ctx.fillStyle = grd;
                    ctx.fillRect(0, y, this.W, this.H - y);

                    // floor highlights
                    ctx.globalAlpha = 0.35;
                    ctx.strokeStyle = "rgba(255,255,255,.10)";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.left, this.floorY);
                    ctx.lineTo(this.right, this.floorY);
                    ctx.stroke();

                    // subtle floor texture lines
                    ctx.globalAlpha = 0.12;
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 10; i++) {
                        const yy = y + 18 + i * 12;
                        ctx.beginPath();
                        ctx.moveTo(this.left, yy);
                        ctx.lineTo(this.right, yy + Math.sin(time * 0.6 + i) * 2);
                        ctx.stroke();
                    }

                    // vignette
                    const v = ctx.createRadialGradient(this.W / 2, this.H * 0.65, 120, this.W / 2, this.H * 0.65, 760);
                    v.addColorStop(0, "rgba(0,0,0,0)");
                    v.addColorStop(1, "rgba(0,0,0,.55)");
                    ctx.fillStyle = v;
                    ctx.globalAlpha = 1;
                    ctx.fillRect(0, 0, this.W, this.H);

                    ctx.restore();
                }

                loop() {
                    const t = now();
                    let dt = (t - this.last) / 1000;
                    this.last = t;

                    // clamp dt to avoid spikes
                    dt = clamp(dt, 0, 1 / 20);

                    this.update(dt);
                    this.render(t);

                    requestAnimationFrame(() => this.loop());
                }
            }

            // -----------------------------
            // Boot
            // -----------------------------
            const canvas = document.getElementById("game");
            const game = new Game(canvas);

            // Start with timer UI correct
            game.ui.updateTimer(60);
        })();
    </script>
</body>

</html>